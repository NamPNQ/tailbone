/**
 * @author Maciej Zasada maciej@unit9.com
 * @copyright 2013 UNIT9 Ltd.
 * Date: 6/3/13
 * Time: 1:34 AM
 */

var EventDispatcher = function () {

    this._handlers = {};

};

EventDispatcher.prototype = {

    /**
     * Binds event by name
     * @param type {string} type of event to bind
     * @param handler {function}
     */
    bind: function (type, handler) {

        console.log('* bind', type);
        this._handlers[type] = this._handlers[type] || [];
        this._handlers[type].push(handler);

    },

    /**
     * Unbinds event by name
     * @param type {string} type of event to unbind
     * @param handler {function} (optional)
     */
    unbind: function (type, handler) {

        console.log('* unbind', type);
        if (this._handlers[type]) {

            if (handler) {

                this._handlers[type].splice(this._handlers[type].indexOf(handler), 1);

            } else {

                this._handlers[type] = [];

            }

        }

    },

    /**
     * Triggers event of given type type passes arguments to handlers
     * @param type {string} type of event to be triggered
     * @param args... {object...} arguments to be passed to event handler
     */
    trigger: function (type, args) {

        var i;

        args = Array.prototype.slice.apply(arguments).slice(1);
        console.log('* trigger', type, args);

        if (this._handlers[type]) {

            for (i = 0; i < this._handlers[type].length; ++i) {

                this._handlers[type][i].apply(this, args);

            }

        }


    }

};


/* **********************************************
     Begin StateDrive.js
********************************************** */

/**
 * @author Doug Fritz dougfritz@google.com
 * @author Maciej Zasada maciej@unit9.com
 * @copyright 2013 UNIT9 Ltd.
 * Date: 6/2/13
 * Time: 11:04 PM
 */

/**
 * Constructs new StateDrive
 * @constructor
 */
var StateDrive = function () {

    this._state = 0;
    this._callQueue = {};

};

StateDrive.prototype = new EventDispatcher();

/**
 * Gets current object state
 * @returns {int} current state
 */
StateDrive.prototype.getState = function () {

    return this._state;

};

/**
 * Sets current object state
 * @param value {int} new state
 */
StateDrive.prototype.setState = function (value) {

    this._state = value;
    this.executeQueuedCalls();

};

/**
 * Specifies minimum state for the instance function calls. A function call of name 'name' will be delayed until the instance reaches given 'state'
 * @param name {string}
 * @param args... {array...} optional validator
 * @param state {int}
 */
StateDrive.prototype.setMinCallState = function (name, args, state) {

    var originalFunction = this[name],
        stateId = arguments[arguments.length - 1],
        argumentValidators = arguments.length > 2 ? Array.prototype.slice.apply(arguments).slice(1, arguments.length - 1) : [],
        i;

    this[name] = function () {

        if (this._state >= stateId || arguments.length < argumentValidators.length) {

            return originalFunction.apply(this, arguments);

        } else {

            for (i = 0; i < argumentValidators.length; ++i) {

                if (!arguments[i].match(argumentValidators[i])) {

                    return originalFunction.apply(this, arguments);

                }

            }

            return this.queueCall(name, arguments, stateId);

        }

    };

};

/**
 * Queues function call until a given min. state is reached
 * @param name {string}
 * @param args {array}
 * @param state {int}
 */
StateDrive.prototype.queueCall = function (name, args, state) {

    this._callQueue[state] = this._callQueue[state] || [];
    this._callQueue[state].push({name: name, args: args});

};

/**
 * Executes queued calls for current and lower states
 */
StateDrive.prototype.executeQueuedCalls = function () {

    var i, j;

    for (i = 0; i <= this._state; ++i) {

        if (this._callQueue[i]) {

            for (j = 0; j < this._callQueue[i].length; ++j) {

                this[this._callQueue[i][j].name].apply(this, this._callQueue[i][j].args);

            }

            this._callQueue[i] = [];

        }

    }

};


/* **********************************************
     Begin Node.js
********************************************** */

/**
 * @author Doug Fritz dougfritz@google.com
 * @author Maciej Zasada maciej@unit9.com
 * @copyright 2013 UNIT9 Ltd.
 * Date: 6/2/13
 * Time: 11:28 PM
 */

var Node = function () {



};

Node.prototype = new StateDrive();


/* **********************************************
     Begin Mesh.js
********************************************** */

/**
 * @author Doug Fritz dougfritz@google.com
 * @author Maciej Zasada maciej@unit9.com
 * @copyright 2013 Google & UNIT9
 * Date: 6/2/13
 * Time: 10:53 PM
 */

var Mesh = function (id, options) {

    /* constructor */
    StateDrive.call(this);
    this.id = id;
    this.config(options);
    this.setState(Mesh.STATE.INITIALISED);
    this.setMinCallState('connect', Mesh.STATE.INITIALISED);
    this.setMinCallState('trigger', 'test', Mesh.STATE.CONNECTED);
    this.setMinCallState('unbind', /.*/, Mesh.STATE.CONNECTED);

    /* privilaged members */
    /**
     * Connects the Mesh to server
     */
    this.connect = function () {

        var self = this;

        if (!this.options.apiUrl) {

            throw new Error('API URL not specified');

        }

        console.log('* connect');

        restGet(this.options.apiUrl + '/mesh/' + (this.id || ''), function (response) {

            onConnectionPointInfoSuccess(self, response);

        }, function () {

            onConnectionPointInfoFailure();

        });

    };

    /* private members */
    var socket = null;
    var nodes = [];

    /**
     * Connects to WebSocket server
     * @param self {Mesh}
     * @param url {string}
     */
    var connectToSocket = function (self, url) {

        socket = new WebSocket(url);

        socket.onopen = function () {

            onSocketOpen(self);

        };

        socket.onmessage = function (message) {

            onSocketMessage(self, message);

        };

        socket.onerror = function () {

            onSocketError(self);

        };

        socket.onclose = function () {

            onSocketClose(self);

        }

    };

    var handleSystemMessage = function (self, message) {

//        enter, leave
//        self.handleCustomMessage(self, overriddenMessage);
        return false;

    };

    var handleCustomMessage = function (self, message) {

//        self.trigger(...);

    };

    /**
     * Triggers asynchronous http GET request
     * @param url {string}
     * @param successHandler {function}
     * @param failureHandler {function}
     */
    var restGet = function (url, successHandler, failureHandler) {

        var xmlhttp;

        if (window.XMLHttpRequest) {

            xmlhttp = new XMLHttpRequest();

        } else {

            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

        }

        xmlhttp.onreadystatechange = function() {

            if (xmlhttp.readyState === 4) {

                if (xmlhttp.status === 200 && typeof successHandler === 'function') {

                    successHandler(xmlhttp.responseText);

                } else {

                    failureHandler(xmlhttp.status);

                }

            }

        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();

    };

    /* handlers */
    var onConnectionPointInfoSuccess = function (self, info) {

        var infoObject;

        try {

            infoObject = JSON.parse(info);

        } catch (e) {

            throw new Error('Could not establish connection with server');

        }

        console.log('- connection point', infoObject);
        connectToSocket(self, infoObject.url);

    };

    var onConnectionPointInfoFailure = function () {

        throw new Error('Could not establish connection with server');

    };

    var onSocketOpen = function (self) {

        self.setState(Mesh.STATE.CONNECTED);
        self.trigger('open');

    };

    var onSocketMessage = function (self, message) {

        console.log('- socket message', message);
        if (!handleSystemMessage(self, message)) {

            handleCustomMessage(self, message);

        }

    };

    var onSocketError = function (self) {

        self.setState(Mesh.STATE.UNDEFINED);
        self.trigger('error');

    };

    var onSocketClose = function (self) {

        self.setState(Mesh.STATE.INITIALISED);
        self.trigger('close');

    };

};

Mesh.STATE = {

    INVALID: -1,
    UNDEFINED: 0,
    INITIALISED: 1,
    CONNECTED: 2

};

/**
 * Default Mesh options
 * @type {{apiUrl: null}}
 */
Mesh.options = {

    apiUrl: null

};

Mesh.prototype = new StateDrive();

/**
 * Extends shared Mesh.options with custom config
 * @param options {object}
 */
Mesh.prototype.config = function (options) {

    var field;

    this.options = {};

    for (field in Mesh.options) {

        this.options[field] = Mesh.options[field];

    }

    if (typeof options === 'object') {

        for (field in options) {

            this.options[field] = options[field];

        }

    }

};

<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="extras/qunit-git.css">
  </head>
  <body>
  <div id="qunit"></div>
  <script src="extras/qunit-git.js" type="text/javascript"></script>
  <script src="extras/jquery.min.js"></script>
  <script src="/tailbone.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">

      test('export', function () {
          ok(tailbone.Mesh, 'Mesh exported as tailbone.Mesh');
      });

      module('tailbone.Mesh basics', {
        setup: function() {
            this.defaultOptions = tailbone.Mesh.options;
            tailbone.Mesh.options.autoConnect = false;
        },
        teardown: function() {
            tailbone.Mesh.options = this.defaultOptions;
        }
      });

      test('constructor', function() {

          ok(new tailbone.Mesh(), 'new tailbone.Mesh() succeeds');
          ok(new tailbone.Mesh('id'), 'new tailbone.Mesh((string) id) succeeds');
          ok(new tailbone.Mesh('id', '/api/mesh'), 'new tailbone.Mesh((string) id, (string) api) succeeds');
          ok(new tailbone.Mesh('id', {ws: 'ws://localhost:2345/id'}), 'new tailbone.Mesh((string) id, (object) options) succeeds');
          ok(new tailbone.Mesh(null, '/api/mesh'), 'new tailbone.Mesh(null, (string) api) succeeds');
          ok(new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}), 'new tailbone.Mesh(null, (object) options) succeeds');

          throws(function () {
              new tailbone.Mesh(1);
          }, 'new tailbone.Mesh((number) id) throws Error, id needs to be string');

      });

      test('options', function() {

          equal(new tailbone.Mesh(null, '/api/mesh').options.api, '/api/mesh', 'new tailbone.Mesh(null, (string) options): options is considered options.api');
          equal(new tailbone.Mesh(null, {api: '/api/mesh'}).options.api, '/api/mesh', 'new tailbone.Mesh(null, (object) options) transcribes options.api');
          equal(new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}).options.ws, 'ws://localhost:2345/id', 'new tailbone.Mesh(null, (object) options) transcribes options.ws');
          equal(new tailbone.Mesh(null, {custom: 123}).options.custom, 123, 'new tailbone.Mesh(null, (object) options) transcribes custom properties');

      });

      module('tailbone.Mesh connections', {
        setup: function() {
            this.defaultOptions = tailbone.Mesh.options;
            tailbone.Mesh.options.useWebRTC = false;
        },
        teardown: function() {
            tailbone.Mesh.options = this.defaultOptions;
        }
      });

      asyncTest('exist', 5, function () {

          var mesh1 = new tailbone.Mesh('id3', {ws: 'ws://localhost:2345/id3'});
          var mesh2 = new tailbone.Mesh('id3', {ws: 'ws://localhost:2345/id3'});

          mesh1.bind('exist', function () {

              ok(true, '\'exist\' triggered upon connection when there are no peer nodes');
              equal(arguments.length, 0, 'arguments.length === 0 when there are no peer nodes already in the mesh');

              mesh2.connect();

          });

          mesh2.bind('exist', function() {

              ok(true, '\'exist\' triggered upon connection when peer nodes exist');
              equal(arguments.length, 1, 'arguments.length === 1 when there is one peer node already in the mesh');
              ok(typeof arguments[0], 'object', 'arguments are Node class instances');

              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

      asyncTest('enter', 4, function () {

          var mesh1 = new tailbone.Mesh('id4', {ws: 'ws://localhost:2345/id4'});
          var mesh2 = new tailbone.Mesh('id4', {ws: 'ws://localhost:2345/id4'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function () {

              ok(true, '\'enter\' triggered upon peer connection');
              equal(arguments.length, 1, 'arguments.length === 1 when one peer connected');
              equal(typeof arguments[0], 'object', 'arguments are Node class instances');
              equal(mesh1.peers.length, 1, 'node added to Mesh.peers');

              mesh1.disconnect();
              start();
          
          });

          mesh2.bind('exist', function() {
            mesh2.disconnect();
          });

          mesh1.connect();

      });

      asyncTest('leave', 3, function () {

          var mesh1 = new tailbone.Mesh('id5', {ws: 'ws://localhost:2345/id5'});
          var mesh2 = new tailbone.Mesh('id5', {ws: 'ws://localhost:2345/id5'});

          mesh2.bind('exist', function () {

            mesh2.disconnect();

          });

          mesh1.bind('leave', function () {

              ok(true, '\'leave\' triggered upon peer disconnection');
              equal(arguments.length, 1, 'arguments.length === 1 when one peer disconnected');
              equal(typeof arguments[0], 'object', 'arguments are Node class instances');

              mesh1.disconnect();
              start();

          });

      });

      asyncTest('simple bind', 1, function() {
          var mesh1 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              mesh2 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'});
          var mesh3 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'});

          mesh1.bind('exist', function() { 
            mesh2.connect(); 
            mesh3.connect();
          });
          mesh2.bind('exist', function(n) {
            mesh2.trigger('test');
          });
          mesh1.bind('test', function() {
            console.log(arguments);
            ok(true, 'sure');
            start();
          });
          mesh1.connect();
          window.mesh1 = mesh1; window.mesh2 = mesh2;
      });
//
      asyncTest('bind', 10, function () {

          var mesh1 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              mesh2 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              mesh3 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              triggerCount = 0;

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh2.bind('open', function () {

              mesh3.connect();

          });

          mesh1.bind('enter', function (node) {

              node.bind('test', function () {});

          });

          mesh2.bind('bind', function (type) {
              console.log('got bind', type);

              ok(true, 'mesh2 received mesh1\'s \'bind\'');
              equal(type, 'test', 'received \'bind\' type is \'test\'');

          });

          mesh3.bind('bind', function (type) {

              ok(true, 'mesh3 received mesh1\'s \'bind\'');
              equal(type, 'test', 'received \'bind\' type is \'test\'');
              mesh2.trigger('test');
              mesh3.trigger('test');

          });

          mesh1.bind('test', function () {

              ok(true, 'mesh1 received \'test\' after binding to it');

              if (++triggerCount === 2) {
                  mesh1.disconnect();
                  mesh2.disconnect();
                  mesh3.disconnect();
                  start();
              }

          });

          mesh1.connect();

      });

      asyncTest('unbind', 2, function () {

          var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}),
              mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

          // mesh1.bind('open', function () {

          //     mesh2.connect();

          // });

          // mesh1.bind('enter', function () {

          //     mesh1.peers[0].bind('test', function () {});

          // });

          // mesh2.bind('bind', function (type) {

          //     mesh2.peers[0].trigger(type, 15);

          // });

          // mesh1.bind('test', function () {

          //     ok(true, '"test" has been triggered on mesh1 because it has been bound to');
          //     mesh1.unbind('test');

          // });

          // mesh2.bind('unbind', function () {

          //     ok(true, 'mesh2 received mesh1\'s \'unbind\'');
          //     mesh2.peers[0].trigger('test', 15);
          //     mesh1.disconnect();
          //     mesh2.disconnect();
          //     start();

          // });

          // mesh1.connect();

          mesh1.bind('test', function() {
            ok(true, 'mesh1 got test');
            start();
          });

          mesh2.bind('exist', function(n) {
            mesh2.trigger('test');
            // console.log('opening');
            // console.log(n);
            // setTimeout(function() {
            // }, 100);
          });

          mesh1.connect();
          mesh2.connect();


      });

      asyncTest('trigger', 3, function () {

          var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}),
              mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function (node) {

              console.log('mesh 1 enter');
              node.bind('gyro', function () {});

          });

          mesh2.bind('bind', function (type) {

              console.log('mesh 2 got remote bind');
              ok(true, 'mesh3 received mesh2\'s \'bind\'');
              equal(type, 'gyro', 'received \'bind\' type is \'test\'');
              mesh2.trigger('gyro', 123.34, 241.22, 90.01);

          });

          mesh1.bind('gyro', function () {

              ok(true, 'mesh1 received \'gyro\' after binding to it');
              console.log('-- gyro', arguments);
              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

    asyncTest('pre binding', 3, function() {
        var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}), 
            mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

        mesh1.bind('enter', function(node) {
            ok(true, 'node from mesh2 has entered');
        });

        // TODO: the bind signaling of being ready
        // should happen before the node enters the lobby and is ready
        // you shouldn't have to listen to bind before you trigger
        // an event that you had bound
        mesh2.bind('bind', function() {
            console.log.apply(console, arguments);
            mesh2.trigger('test');
        });

        mesh1.bind('test', function() {
            ok(true, 'test triggered on mesh1.');
            mesh1.disconnect();
            mesh2.disconnect();
            start();
        });

        mesh2.bind('test', function() {
            ok(true, 'test triggered on mesh2');
        });

        mesh1.connect();
        mesh2.connect();

    });

    asyncTest('bad agent', function() {

        var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}), 
            mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}),
            mesh3 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

        mesh3.bind('exist', function(node1, node2) {
            ok(arguments.length == 2, 'mesh 3 bound');
            mesh1.disconnect();
            mesh2.disconnect();
            mesh3.disconnect();
            start();
        });

        mesh1.connect();
        mesh2.connect();
        mesh3.connect();
    })

  </script>
  </body>
</html>

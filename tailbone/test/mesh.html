<!doctype html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="extras/qunit-git.css">
  </head>
  <body>
  <div id="qunit"></div>
  <script src="extras/qunit-git.js" type="text/javascript"></script>
  <script src="extras/jquery.min.js"></script>
  <script src="/tailbone.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">

      module('tailbone.Mesh');

      test('export', function () {

          ok(tailbone.Mesh, 'Mesh exported as tailbone.Mesh');

      });

      test('constructor', function() {

          ok(new tailbone.Mesh(), 'new tailbone.Mesh() succeeds');
          ok(new tailbone.Mesh('id'), 'new tailbone.Mesh((string) id) succeeds');
          ok(new tailbone.Mesh('id', '/api/mesh'), 'new tailbone.Mesh((string) id, (string) api) succeeds');
          ok(new tailbone.Mesh('id', {ws: 'ws://localhost:2345/id'}), 'new tailbone.Mesh((string) id, (object) options) succeeds');
          ok(new tailbone.Mesh(null, '/api/mesh'), 'new tailbone.Mesh(null, (string) api) succeeds');
          ok(new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}), 'new tailbone.Mesh(null, (object) options) succeeds');

          throws(function () {
              new tailbone.Mesh(1);
          }, 'new tailbone.Mesh((number) id) throws Error, id needs to be string');

      });

      test('options', function() {

          equal(new tailbone.Mesh(null, '/api/mesh').options.api, '/api/mesh', 'new tailbone.Mesh(null, (string) options): options is considered options.api');
          equal(new tailbone.Mesh(null, {api: '/api/mesh'}).options.api, '/api/mesh', 'new tailbone.Mesh(null, (object) options) transcribes options.api');
          equal(new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}).options.ws, 'ws://localhost:2345/id', 'new tailbone.Mesh(null, (object) options) transcribes options.ws');
          equal(new tailbone.Mesh(null, {custom: 123}).options.custom, 123, 'new tailbone.Mesh(null, (object) options) transcribes custom properties');

      });

//      asyncTest('connect()', 7, function () {
//
//          var mesh1 = new tailbone.Mesh(null, '/api/mesh'),
//              mesh2 = new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}),
//              mesh3 = new tailbone.Mesh('id1', '/api/mesh'),
//              mesh4 = new tailbone.Mesh('id1', {ws: 'ws://localhost:2345/id2'}),
//              mesh5 = new tailbone.Mesh('id1', {ws: 'ws://localhost:2345/id2', autoConnect: true}),
//              triggers = 0;
//
//          var onItemDone = function () {
//
//              if (++triggers === 7) {
//                  mesh1.disconnect();
//                  mesh2.disconnect();
//                  mesh3.disconnect();
//                  mesh4.disconnect();
//                  mesh5.disconnect();
//                  start();
//              }
//
//          };
//
//          mesh1.self.bind('open', function (channel) {
//
//              ok(true, '[options.api]: Mesh.self: successfully connected to WS server via options.api');
//              onItemDone();
//
//          });
//
//          mesh1.bind('open', function (channel) {
//
//              ok(true, '[options.api]: Mesh: successfully connected to WS server via options.api');
//              onItemDone();
//
//          });
//
//          mesh2.self.bind('open', function (channel) {
//
//              ok(true, '[options.ws]: Mesh.self: successfully connected to WS server via options.ws');
//              onItemDone();
//
//          });
//
//          mesh2.bind('open', function (channel) {
//
//              ok(true, '[options.ws]: Mesh: successfully connected to WS server via options.ws');
//              onItemDone();
//
//          });
//
//          mesh3.self.bind('open', function (channel) {
//
//              equal(mesh3.id, 'id1', '[options.api]: Mesh.id is derived from constructor parameter');
//              onItemDone();
//
//          });
//
//          mesh4.self.bind('open', function (channel) {
//
//              equal(mesh4.id, 'id2', '[options.ws]: Mesh.id is derived from options.ws and not from constructor \'id\' argument');
//              onItemDone();
//
//          });
//
//          mesh5.self.bind('open', function (channel) {
//
//              ok(true, 'connect() called automatically by options.autoConnect');
//              onItemDone();
//
//          });
//
//          mesh1.connect();
//          mesh2.connect();
//          mesh3.connect();
//          mesh4.connect();
//
//      });
//
//      asyncTest('open', 24, function () {
//
//          var mesh1 = new tailbone.Mesh(null, '/api/mesh'),
//              mesh2 = new tailbone.Mesh(null, {ws: 'ws://localhost:2345/id'}),
//              triggers = 0;
//
//          var onItemComplete = function () {
//
//              if (++triggers === 4) {
//                  mesh1.disconnect();
//                  mesh2.disconnect();
//                  start();
//              }
//
//          };
//
//          mesh1.self.bind('open', function (channel) {
//
//              ok(true, '[options.api]: Mesh.self: triggered \'open\'');
//              ok(channel, '[options.api]: Mesh.self: channel passed to \'open\' handler');
//              ok(channel.localNode, '[options.api]: Mesh.self: channel has localNode');
//              ok(channel.remoteNode, '[options.api]: Mesh.self: channel has remoteNode');
//              equal(mesh1.self, channel.remoteNode, '[options.api]: Mesh.self: channel.localNode === mesh.self');
//              equal(channel.localNode, channel.remoteNode, '[options.api]: Mesh.self: channel.localNode === channel.remoteNode (there is no remote connection, only self Node is open');
//              onItemComplete();
//
//          });
//
//          mesh1.bind('open', function (channel) {
//
//              ok(true, '[options.api]: Mesh: triggered \'open\'');
//              ok(channel, '[options.api]: Mesh: channel passed to \'open\' handler');
//              ok(channel.localNode, '[options.api]: Mesh: channel has localNode');
//              ok(channel.remoteNode, '[options.api]: Mesh: channel has remoteNode');
//              equal(mesh1.self, channel.remoteNode, '[options.api]: Mesh.self: channel.localNode === mesh.self');
//              equal(channel.localNode, channel.remoteNode, '[options.api]: Mesh.self: channel.localNode === channel.remoteNode (there is no remote connection, only self Node is open');
//              onItemComplete();
//
//          });
//
//          mesh2.self.bind('open', function (channel) {
//
//              ok(true, '[options.ws]: Mesh.self: triggered \'open\'');
//              ok(channel, '[options.ws]: Mesh.self: channel passed to \'open\' handler');
//              ok(channel.localNode, '[options.ws]: Mesh.self: channel has localNode');
//              ok(channel.remoteNode, '[options.ws]: Mesh.self: channel has remoteNode');
//              equal(mesh2.self, channel.remoteNode, '[options.ws]: Mesh.self: channel.localNode == mesh.self');
//              equal(channel.localNode, channel.remoteNode, '[options.ws]: Mesh.self: channel.localNode === channel.remoteNode (there is no remote connection, only self Node is open');
//              onItemComplete();
//
//          });
//
//          mesh2.bind('open', function (channel) {
//
//              ok(true, '[options.ws]: Mesh: triggered \'open\'');
//              ok(channel, '[options.ws]: Mesh: channel passed to \'open\' handler');
//              ok(channel.localNode, '[options.ws]: Mesh: channel has localNode');
//              ok(channel.remoteNode, '[options.ws]: Mesh: channel has remoteNode');
//              equal(mesh2.self, channel.remoteNode, '[options.ws]: Mesh.self: channel.localNode == mesh.self');
//              equal(channel.localNode, channel.remoteNode, '[options.ws]: Mesh.self: channel.localNode === channel.remoteNode (there is no remote connection, only self Node is open');
//              onItemComplete();
//
//          });
//
//          mesh1.connect();
//          mesh2.connect();
//
//      });
//
      asyncTest('exist', 5, function () {

          var mesh1 = new tailbone.Mesh('id3', {ws: 'ws://localhost:2345/id3'});
          var mesh2 = new tailbone.Mesh('id3', {ws: 'ws://localhost:2345/id3'});

          mesh1.bind('exist', function () {

              ok(true, '\'exist\' triggered upon connection when there are no peer nodes');
              equal(arguments.length, 0, 'arguments.length === 0 when there are no peer nodes already in the mesh');

              mesh2.connect();

          });

          mesh2.bind('exist', function() {

              ok(true, '\'exist\' triggered upon connection when peer nodes exist');
              equal(arguments.length, 1, 'arguments.length === 1 when there is one peer node already in the mesh');
              ok(typeof arguments[0], 'object', 'arguments are Node class instances');

              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

      asyncTest('enter', 4, function () {

          var mesh1 = new tailbone.Mesh('id4', {ws: 'ws://localhost:2345/id4'});
          var mesh2 = new tailbone.Mesh('id4', {ws: 'ws://localhost:2345/id4'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function () {

              ok(true, '\'enter\' triggered upon peer connection');
              equal(arguments.length, 1, 'arguments.length === 1 when one peer connected');
              equal(typeof arguments[0], 'object', 'arguments are Node class instances');
              equal(mesh1.peers.length, 1, 'node added to Mesh.peers');

              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

      asyncTest('leave', 3, function () {

          var mesh1 = new tailbone.Mesh('id5', {ws: 'ws://localhost:2345/id5'});
          var mesh2 = new tailbone.Mesh('id5', {ws: 'ws://localhost:2345/id5'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function () {

              mesh2.disconnect();

          });

          mesh1.bind('leave', function () {

              ok(true, '\'leave\' triggered upon peer disconnection');
              equal(arguments.length, 1, 'arguments.length === 1 when one peer disconnected');
              equal(typeof arguments[0], 'object', 'arguments are Node class instances');

              mesh1.disconnect();
              start();

          });

          mesh1.connect();

      });
//
      asyncTest('bind', 6, function () {

          var mesh1 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              mesh2 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              mesh3 = new tailbone.Mesh('id6', {ws: 'ws://localhost:2345/id6'}),
              triggerCount = 0;

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh2.bind('open', function () {

              mesh3.connect();

          });

          mesh1.bind('enter', function (node) {

              node.bind('test', function () {});

          });

          mesh2.bind('bind', function (type) {

              ok(true, 'mesh2 received mesh1\'s \'bind\'');
              equal(type, 'test', 'received \'bind\' type is \'test\'');

          });

          mesh3.bind('bind', function (type) {

              ok(true, 'mesh3 received mesh1\'s \'bind\'');
              equal(type, 'test', 'received \'bind\' type is \'test\'');
              mesh2.trigger('test');
              mesh3.trigger('test');

          });

          mesh1.bind('test', function () {

              ok(true, 'mesh1 received \'test\' after binding to it');

              if (++triggerCount === 2) {
                  mesh1.disconnect();
                  mesh2.disconnect();
                  mesh3.disconnect();
                  start();
              }

          });

          mesh1.connect();

      });

      asyncTest('unbind', 2, function () {

          var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}),
              mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function () {

              mesh1.peers[0].bind('test', function () {});

          });

          mesh2.bind('bind', function (type) {

              mesh2.peers[0].trigger(type, 15);

          });

          mesh1.bind('test', function () {

              ok(true, '\'test\' has been triggered on mesh1 because it has been bound to');
              mesh1.unbind('test');

          });

          mesh2.bind('unbind', function () {

              ok(true, 'mesh2 received mesh1\'s \'unbind\'');
              mesh2.peers[0].trigger('test', 15);
              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

      asyncTest('trigger', 3, function () {

          var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}),
              mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});

          mesh1.bind('open', function () {

              mesh2.connect();

          });

          mesh1.bind('enter', function (node) {

              console.log('mesh 1 enter');
              node.bind('gyro', function () {});

          });

          mesh2.bind('bind', function (type) {

              console.log('mesh 2 got remote bind');
              ok(true, 'mesh3 received mesh2\'s \'bind\'');
              equal(type, 'gyro', 'received \'bind\' type is \'test\'');
              mesh2.trigger('gyro', 123.34, 241.22, 90.01);

          });

          mesh1.bind('gyro', function () {

              ok(true, 'mesh1 received \'gyro\' after binding to it');
              console.log('-- gyro', arguments);
              mesh1.disconnect();
              mesh2.disconnect();
              start();

          });

          mesh1.connect();

      });

    asyncTest('partial binding', 3, function() {
        var mesh1 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'}), 
            mesh2 = new tailbone.Mesh('id7', {ws: 'ws://localhost:2345/id7'});
        window.mesh1 = mesh1;
        window.mesh2 = mesh2;

        mesh1.bind('enter', function(node) {
            ok(true, 'node from mesh2 has entered');
            mesh2.trigger('test');

            start();
        });

        mesh1.bind('test', function() {
            ok(true, 'test triggered on mesh1.');
        });

        mesh2.bind('test', function() {
            ok(true, 'test triggered on mesh2');
        });

        mesh1.connect();
        mesh2.connect();

    });

  </script>
  </body>
</html>
